name: Update Packages

on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:

jobs:
  list-packages:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}
            experimental-features = nix-command flakes
      - id: set-matrix
        run: |
          set -e
          JSON=$(nix flake show --json)
          # Select packages, exclude Thorium variants that are handled by a single script (to avoid duplicate runs)
          # We'll run the update script for 'thorium-avx' which updates all thorium variants.
          # We can filter out thorium-avx2, sse3, sse4 from the matrix to save resources, 
          # assuming our script is robust.
          # Or just let them run (the script updates the file, git diff will handle idempotency).
          # To be clean, let's just run all. My script is fast.
          
          PACKAGES=$(echo "$JSON" | jq -c '.packages."x86_64-linux" | keys | map(select(. != "override" and . != "overrideDerivation"))')
          echo "matrix=$PACKAGES" >> $GITHUB_OUTPUT

  update-packages:
    needs: list-packages
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.list-packages.outputs.matrix) }}
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}
            experimental-features = nix-command flakes

      - name: Install dependencies
        run: |
          nix profile install nixpkgs#jq nixpkgs#curl nixpkgs#gnused nixpkgs#nix-update
          
      - name: Update ${{ matrix.package }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGE="${{ matrix.package }}"
          echo "Checking update script for $PACKAGE..."
          
          # Check if updateScript is defined
          SCRIPT_JSON=$(nix eval --json .#${PACKAGE}.passthru.updateScript 2>/dev/null || echo "null")
          
          if [ "$SCRIPT_JSON" == "null" ]; then
            echo "No updateScript found for $PACKAGE. Skipping."
            exit 0
          fi
          
          TYPE=$(echo "$SCRIPT_JSON" | jq -r 'type')
          
          if [ "$TYPE" == "string" ]; then
            echo "Found custom update script (path): $SCRIPT_JSON"
            SCRIPT_NAME=$(echo "$SCRIPT_JSON" | tr -d '"') 
            BASENAME=$(basename "$SCRIPT_NAME")
            
            # Find it in packages using heuristic
            LOCAL_SCRIPT=$(find packages -name "$BASENAME" | head -n 1)
            
            if [ -n "$LOCAL_SCRIPT" ]; then
               echo "Found local script: $LOCAL_SCRIPT"
               chmod +x "$LOCAL_SCRIPT"
               ./"$LOCAL_SCRIPT"
            else
               echo "Could not find local source for script $BASENAME. execution might fail if it tries to write to store."
               "$SCRIPT_NAME"
            fi
            
          elif [ "$TYPE" == "array" ]; then
             echo "Found standard updateScript list."
             # Extract the first element (command) and the rest (args)
             CMD=$(echo "$SCRIPT_JSON" | jq -r '.[0]')
             ARGS=$(echo "$SCRIPT_JSON" | jq -r '.[1:] | join(" ")')
             
             echo "Original Command: $CMD"
             echo "Args: $ARGS"
             
             # If command contains "nix-update", swap it for the one in PATH
             if [[ "$CMD" == *"nix-update"* ]]; then
                echo "Detected nix-update store path. Using system nix-update."
                CMD="nix-update"
             fi
             
             # Execute
             echo "Running: $CMD $ARGS"
             eval "$CMD $ARGS"
          else
             echo "Unknown updateScript type: $TYPE"
             exit 1
          fi
          
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore(deps): update ${{ matrix.package }}"
          title: "Update ${{ matrix.package }}"
          body: "Automated update for ${{ matrix.package }}"
          branch: "update-package-${{ matrix.package }}"
          delete-branch: true
          labels: automated
